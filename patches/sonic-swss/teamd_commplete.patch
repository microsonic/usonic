Index: usonic/sm/sonic-swss/cfgmgr/teammgr.cpp

--- usonic.orig/sm/sonic-swss/cfgmgr/teammgr.cpp
+++ usonic/sm/sonic-swss/cfgmgr/teammgr.cpp
@@ -7,12 +7,16 @@
 #include "portmgr.h"
 
 #include <algorithm>
+#include <iostream>
+#include <fstream>
 #include <sstream>
 #include <thread>
 
 #include <net/if.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
+#include <signal.h>
+
 
 using namespace std;
 using namespace swss;
@@ -108,6 +112,20 @@ void TeamMgr::doTask(Consumer &consumer)
     }
 }
 
+
+void TeamMgr::cleanTeamProcesses()
+{
+    SWSS_LOG_ENTER();
+    SWSS_LOG_NOTICE("Cleaning up LAGs during shutdown...");
+    for (const auto& it: m_lagList)
+    {
+        //This will call team -k kill -t <teamdevicename> which internally send SIGTERM 
+        removeLag(it);
+    }
+
+    return;
+}
+
 void TeamMgr::doLagTask(Consumer &consumer)
 {
     SWSS_LOG_ENTER();
@@ -373,8 +391,41 @@ task_process_status TeamMgr::addLag(const string &alias, int min_links, bool fal
     string res;
 
     stringstream conf;
+
+    const string dump_path = "/var/warmboot/teamd/";
+    MacAddress mac_boot = m_mac;
+
+    // set portchannel mac same with mac before warmStart, when warmStart and there
+    // is a file written by teamd.
+    ifstream aliasfile(dump_path + alias);
+    if (WarmStart::isWarmStart() && aliasfile.is_open())
+    {
+        const int partner_system_id_offset = 40;
+        string line;
+
+        while (getline(aliasfile, line))
+        {
+            ifstream memberfile(dump_path + line, ios::binary);
+            uint8_t mac_temp[ETHER_ADDR_LEN] = {0};
+            uint8_t null_mac[ETHER_ADDR_LEN] = {0};
+
+            if (!memberfile.is_open())
+                continue;
+
+            memberfile.seekg(partner_system_id_offset, std::ios::beg);
+            memberfile.read(reinterpret_cast<char*>(mac_temp), ETHER_ADDR_LEN);
+
+            /* During negotiation stage partner info of pdu is empty , skip it */
+            if (memcmp(mac_temp, null_mac, ETHER_ADDR_LEN) == 0)
+                continue;
+
+            mac_boot = MacAddress(mac_temp);
+            break;
+        }
+    }
+
     conf << "'{\"device\":\"" << alias << "\","
-         << "\"hwaddr\":\"" << m_mac.to_string() << "\","
+         << "\"hwaddr\":\"" << mac_boot.to_string() << "\","
          << "\"runner\":{"
          << "\"active\":true,"
          << "\"name\":\"lacp\"";
@@ -395,7 +446,6 @@ task_process_status TeamMgr::addLag(const string &alias, int min_links, bool fal
             alias.c_str(), conf.str().c_str());
 
     string warmstart_flag = WarmStart::isWarmStart() ? " -w -o " : " -r ";
-    const string dump_path = "/var/warmboot/teamd/";
 
     cmd << TEAMD_CMD
         << warmstart_flag

Index: usonic/sm/sonic-swss/cfgmgr/teammgr.h

--- usonic.orig/sm/sonic-swss/cfgmgr/teammgr.h
+++ usonic/sm/sonic-swss/cfgmgr/teammgr.h
@@ -7,6 +7,7 @@
 #include "netmsg.h"
 #include "orch.h"
 #include "producerstatetable.h"
+#include <sys/types.h>
 
 namespace swss {
 
@@ -14,9 +15,11 @@ class TeamMgr : public Orch
 {
 public:
     TeamMgr(DBConnector *cfgDb, DBConnector *appDb, DBConnector *staDb,
-            const vector<TableConnector> &tables);
+            const std::vector<TableConnector> &tables);
 
     using Orch::doTask;
+    void cleanTeamProcesses();
+
 private:
     Table m_cfgMetadataTable;   // To retrieve MAC address
     Table m_cfgPortTable;
@@ -28,7 +31,8 @@ private:
     ProducerStateTable m_appPortTable;
     ProducerStateTable m_appLagTable;
 
-    set<string> m_lagList;
+    std::set<std::string> m_lagList;
+    std::map<std::string, pid_t> m_lagPIDList;
 
     MacAddress m_mac;
 
@@ -37,19 +41,19 @@ private:
     void doLagMemberTask(Consumer &consumer);
     void doPortUpdateTask(Consumer &consumer);
 
-    task_process_status addLag(const string &alias, int min_links, bool fall_back);
-    bool removeLag(const string &alias);
-    task_process_status addLagMember(const string &lag, const string &member);
-    bool removeLagMember(const string &lag, const string &member);
+    task_process_status addLag(const std::string &alias, int min_links, bool fall_back);
+    bool removeLag(const std::string &alias);
+    task_process_status addLagMember(const std::string &lag, const std::string &member);
+    bool removeLagMember(const std::string &lag, const std::string &member);
 
-    bool setLagAdminStatus(const string &alias, const string &admin_status);
-    bool setLagMtu(const string &alias, const string &mtu);
+    bool setLagAdminStatus(const std::string &alias, const std::string &admin_status);
+    bool setLagMtu(const std::string &alias, const std::string &mtu);
 
-    bool isPortEnslaved(const string &);
-    bool findPortMaster(string &, const string &);
-    bool checkPortIffUp(const string &);
-    bool isPortStateOk(const string&);
-    bool isLagStateOk(const string&);
+    bool isPortEnslaved(const std::string &);
+    bool findPortMaster(std::string &, const std::string &);
+    bool checkPortIffUp(const std::string &);
+    bool isPortStateOk(const std::string&);
+    bool isLagStateOk(const std::string&);
 };
 
 }
Index: usonic/sm/sonic-swss/cfgmgr/teammgrd.cpp

--- usonic.orig/sm/sonic-swss/cfgmgr/teammgrd.cpp
+++ usonic/sm/sonic-swss/cfgmgr/teammgrd.cpp
@@ -5,6 +5,7 @@
 #include "netlink.h"
 #include "select.h"
 #include "warm_restart.h"
+#include <signal.h>
 
 using namespace std;
 using namespace swss;
@@ -17,6 +18,14 @@ bool gLogRotate = false;
 ofstream gRecordOfs;
 string gRecordFile;
 
+bool received_sigterm = false;
+
+void sig_handler(int signo)
+{
+    received_sigterm = true;
+    return;
+}
+
 int main(int argc, char **argv)
 {
     Logger::linkToDbNative("teammgrd");
@@ -24,6 +33,9 @@ int main(int argc, char **argv)
 
     SWSS_LOG_NOTICE("--- Starting teammrgd ---");
 
+    /* Register the signal handler for SIGTERM */
+    signal(SIGTERM, sig_handler);
+
     try
     {
         DBConnector conf_db(CONFIG_DB, DBConnector::DEFAULT_UNIXSOCKET, 0);
@@ -53,8 +65,8 @@ int main(int argc, char **argv)
             s.addSelectables(o->getSelectables());
         }
 
-        while (true)
-        {
+        while (!received_sigterm)
+        {            
             Selectable *sel;
             int ret;
 
@@ -73,6 +85,8 @@ int main(int argc, char **argv)
             auto *c = (Executor *)sel;
             c->execute();
         }
+        teammgr.cleanTeamProcesses();
+        SWSS_LOG_NOTICE("Exiting");
     }
     catch (const exception &e)
     {
Index: usonic/sm/sonic-swss/teamsyncd/teamsync.cpp

--- usonic.orig/sm/sonic-swss/teamsyncd/teamsync.cpp
+++ usonic/sm/sonic-swss/teamsyncd/teamsync.cpp
@@ -12,6 +12,8 @@
 #include "warm_restart.h"
 #include "teamsync.h"
 
+#include <unistd.h>
+
 using namespace std;
 using namespace std::chrono;
 using namespace swss;
@@ -107,10 +109,29 @@ void TeamSync::onMsg(int nlmsg_type, struct nl_object *obj)
     if (!type || (strcmp(type, TEAM_DRV_NAME) != 0))
         return;
 
+    unsigned int flags = rtnl_link_get_flags(link);
+    bool admin = flags & IFF_UP;
+    bool oper = flags & IFF_LOWER_UP;
+    unsigned int ifindex = rtnl_link_get_ifindex(link);
+
+    if (type)
+    {
+        SWSS_LOG_INFO(" nlmsg type:%d key:%s admin:%d oper:%d ifindex:%d type:%s",
+                       nlmsg_type, lagName.c_str(), admin, oper, ifindex, type);
+    }
+    else
+    {
+        SWSS_LOG_INFO(" nlmsg type:%d key:%s admin:%d oper:%d ifindex:%d",
+                       nlmsg_type, lagName.c_str(), admin, oper, ifindex);
+    }
+
     if (nlmsg_type == RTM_DELLINK)
     {
-        /* Remove LAG ports and delete LAG */
-        removeLag(lagName);
+        if (m_teamSelectables.find(lagName) != m_teamSelectables.end())
+        {
+            /* Remove LAG ports and delete LAG */
+            removeLag(lagName);
+        }
         return;
     }
 
@@ -127,7 +148,7 @@ void TeamSync::addLag(const string &lagName, int ifindex, bool admin_state,
     std::vector<FieldValueTuple> fvVector;
     FieldValueTuple a("admin_status", admin_state ? "up" : "down");
     FieldValueTuple o("oper_status", oper_state ? "up" : "down");
-    FieldValueTuple m("mtu", to_string(mtu));
+    FieldValueTuple m("mtu", std::to_string(mtu));
     fvVector.push_back(a);
     fvVector.push_back(o);
     fvVector.push_back(m);
@@ -165,12 +186,15 @@ void TeamSync::removeLag(const string &lagName)
     for (auto it : selectable->m_lagMembers)
     {
         m_lagMemberTable.del(lagName + ":" + it.first);
+
+        SWSS_LOG_INFO("Remove member %s before removing LAG %s",
+                it.first.c_str(), lagName.c_str());
     }
 
     /* Delete the LAG */
     m_lagTable.del(lagName);
 
-    SWSS_LOG_INFO("Remove %s", lagName.c_str());
+    SWSS_LOG_INFO("Remove LAG %s", lagName.c_str());
 
     /* Return when the team instance hasn't been tracked before */
     if (m_teamSelectables.find(lagName) == m_teamSelectables.end())
@@ -188,6 +212,19 @@ void TeamSync::removeLag(const string &lagName)
     m_selectablesToRemove.insert(lagName);
 }
 
+void TeamSync::cleanTeamSync()
+{
+    SWSS_LOG_ENTER();
+    SWSS_LOG_NOTICE("Cleaning up LAG teamd resources ...");
+
+    for (const auto& it: m_teamSelectables)
+    {
+        /* Cleanup LAG */
+        removeLag(it.first);
+    }
+    return;
+}
+
 const struct team_change_handler TeamSync::TeamPortSync::gPortChangeHandler = {
     .func       = TeamSync::TeamPortSync::teamdHandler,
     .type_mask  = TEAM_PORT_CHANGE | TEAM_OPTION_CHANGE
@@ -199,32 +236,54 @@ TeamSync::TeamPortSync::TeamPortSync(const string &lagName, int ifindex,
     m_lagName(lagName),
     m_ifindex(ifindex)
 {
-    m_team = team_alloc();
-    if (!m_team)
-    {
-        SWSS_LOG_ERROR("Unable to allocated team socket");
-        throw system_error(make_error_code(errc::address_not_available),
-                           "Unable to allocated team socket");
-    }
-
-    int err = team_init(m_team, ifindex);
-    if (err)
-    {
-        team_free(m_team);
-        m_team = NULL;
-        SWSS_LOG_ERROR("Unable to init team socket");
-        throw system_error(make_error_code(errc::address_not_available),
-                           "Unable to init team socket");
-    }
+    int count = 0;
+    int max_retries = 3;
 
-    err = team_change_handler_register(m_team, &gPortChangeHandler, this);
-    if (err)
+    while (true)
     {
-        team_free(m_team);
-        m_team = NULL;
-        SWSS_LOG_ERROR("Unable to register port change event");
-        throw system_error(make_error_code(errc::address_not_available),
-                           "Unable to register port change event");
+        try
+        {
+            m_team = team_alloc();
+            if (!m_team)
+            {
+                throw system_error(make_error_code(errc::address_not_available),
+                                   "Unable to allocate team socket");
+            }
+
+            int err = team_init(m_team, ifindex);
+            if (err)
+            {
+                team_free(m_team);
+                m_team = NULL;
+                throw system_error(make_error_code(errc::address_not_available),
+                                   "Unable to initialize team socket");
+            }
+
+            err = team_change_handler_register(m_team, &gPortChangeHandler, this);
+            if (err)
+            {
+                team_free(m_team);
+                m_team = NULL;
+                throw system_error(make_error_code(errc::address_not_available),
+                                   "Unable to register port change event");
+            }
+
+            break;
+        }
+        catch (const system_error& e)
+        {
+            if (++count == max_retries)
+            {
+                throw;
+            }
+            else
+            {
+                SWSS_LOG_WARN("Failed to initialize team handler. LAG=%s error=%d:%s, attempt=%d",
+                              lagName.c_str(), e.code().value(), e.what(), count);
+            }
+
+            sleep(1);
+        }
     }
 
     /* Sync LAG at first */
@@ -281,6 +340,9 @@ int TeamSync::TeamPortSync::onChange()
             FieldValueTuple l("status", it.second ? "enabled" : "disabled");
             v.push_back(l);
             m_lagMemberTable->set(key, v);
+
+            SWSS_LOG_INFO("Set LAG %s member %s with status %s",
+                    m_lagName.c_str(), it.first.c_str(), it.second ? "enabled" : "disabled");
         }
     }
 
@@ -290,6 +352,9 @@ int TeamSync::TeamPortSync::onChange()
         {
             string key = m_lagName + ":" + it.first;
             m_lagMemberTable->del(key);
+
+            SWSS_LOG_INFO("Remove member %s from LAG %s",
+                    it.first.c_str(), m_lagName.c_str());
         }
     }
 
@@ -309,7 +374,8 @@ int TeamSync::TeamPortSync::getFd()
     return team_get_event_fd(m_team);
 }
 
-void TeamSync::TeamPortSync::readData()
+uint64_t TeamSync::TeamPortSync::readData()
 {
     team_handle_events(m_team);
+    return 0;
 }
Index: usonic/sm/sonic-swss/teamsyncd/teamsyncd.cpp

--- usonic.orig/sm/sonic-swss/teamsyncd/teamsyncd.cpp
+++ usonic/sm/sonic-swss/teamsyncd/teamsyncd.cpp
@@ -1,5 +1,6 @@
 #include <iostream>
 #include <team.h>
+#include <signal.h>
 #include "logger.h"
 #include "select.h"
 #include "netdispatcher.h"
@@ -9,6 +10,14 @@
 using namespace std;
 using namespace swss;
 
+bool received_sigterm = false;
+
+void sig_handler(int signo)
+{
+    received_sigterm = true;
+    return;
+}
+
 int main(int argc, char **argv)
 {
     swss::Logger::linkToDbNative(TEAMSYNCD_APP_NAME);
@@ -20,30 +29,31 @@ int main(int argc, char **argv)
     NetDispatcher::getInstance().registerMessageHandler(RTM_NEWLINK, &sync);
     NetDispatcher::getInstance().registerMessageHandler(RTM_DELLINK, &sync);
 
-    while (1)
+    /* Register the signal handler for SIGTERM */
+    signal(SIGTERM, sig_handler);
+
+    try
     {
-        try
-        {
-            NetLink netlink;
-
-            netlink.registerGroup(RTNLGRP_LINK);
-            cout << "Listens to teamd events..." << endl;
-            netlink.dumpRequest(RTM_GETLINK);
-
-            s.addSelectable(&netlink);
-            while (true)
-            {
-                Selectable *temps;
-                s.select(&temps, 1000); // block for a second
-                sync.periodic();
-            }
-        }
-        catch (const std::exception& e)
+        NetLink netlink;
+        netlink.registerGroup(RTNLGRP_LINK);
+        cout << "Listens to teamd events..." << endl;
+        netlink.dumpRequest(RTM_GETLINK);
+
+        s.addSelectable(&netlink);
+        while (!received_sigterm)
         {
-            cout << "Exception \"" << e.what() << "\" had been thrown in deamon" << endl;
-            return 0;
+            Selectable *temps;
+            s.select(&temps, 1000); // block for a second
+            sync.periodic();
         }
+        sync.cleanTeamSync();
+        SWSS_LOG_NOTICE("Received SIGTERM Exiting");
+    }
+    catch (const std::exception& e)
+    {
+        cout << "Exception \"" << e.what() << "\" had been thrown in deamon" << endl;
+        return 0;
     }
 
-    return 1;
+    return 0;
 }
Index: usonic/sm/sonic-swss/orchagent/portsorch.cpp

--- usonic.orig/sm/sonic-swss/orchagent/portsorch.cpp
+++ usonic/sm/sonic-swss/orchagent/portsorch.cpp
@@ -2472,39 +2472,51 @@ void PortsOrch::doLagMemberTask(Consumer &consumer)
                     status = fvValue(i);
             }

-            /* Sync an enabled member */
-            if (status == "enabled")
+            if (lag.m_members.find(port_alias) == lag.m_members.end())
             {
-                /* Duplicate entry */
-                if (lag.m_members.find(port_alias) != lag.m_members.end())
+                /* Assert the port doesn't belong to any LAG already */
+                assert(!port.m_lag_id && !port.m_lag_member_id);
+
+                if (!addLagMember(lag, port))
                 {
-                    it = consumer.m_toSync.erase(it);
+                    it++;
                     continue;
                 }
+            }

-                /* Assert the port doesn't belong to any LAG */
-                assert(!port.m_lag_id && !port.m_lag_member_id);
-
-                if (addLagMember(lag, port))
+            /* Sync an enabled member */
+            if (status == "enabled")
+            {
+                /* enable collection first, distribution-only mode
+                 * is not supported on Mellanox platform
+                 */
+                if (setCollectionOnLagMember(port, true) &&
+                    setDistributionOnLagMember(port, true))
+                {
                     it = consumer.m_toSync.erase(it);
+                }
                 else
+                {
                     it++;
+                    continue;
+                }
             }
             /* Sync an disabled member */
             else /* status == "disabled" */
             {
-                /* "status" is "disabled" at start when m_lag_id and
-                 * m_lag_member_id are absent */
-                if (!port.m_lag_id || !port.m_lag_member_id)
+                /* disable distribution first, distribution-only mode
+                 * is not supported on Mellanox platform
+                 */
+                if (setDistributionOnLagMember(port, false) &&
+                    setCollectionOnLagMember(port, false))
                 {
                     it = consumer.m_toSync.erase(it);
-                    continue;
                 }
-
-                if (removeLagMember(lag, port))
-                    it = consumer.m_toSync.erase(it);
                 else
+                {
                     it++;
+                    continue;
+                }
             }
         }
         /* Remove a LAG member */
@@ -2522,9 +2534,13 @@ void PortsOrch::doLagMemberTask(Consumer &consumer)
             }

             if (removeLagMember(lag, port))
+            {
                 it = consumer.m_toSync.erase(it);
+            }
             else
+            {
                 it++;
+            }
         }
         else
         {
@@ -3318,6 +3334,52 @@ bool PortsOrch::removeLagMember(Port &lag, Port &port)
     return true;
 }

+bool PortsOrch::setCollectionOnLagMember(Port &lagMember, bool enableCollection)
+{
+    /* Port must be LAG member */
+    assert(port.m_lag_member_id);
+
+    sai_status_t status = SAI_STATUS_FAILURE;
+    sai_attribute_t attr {};
+
+    attr.id = SAI_LAG_MEMBER_ATTR_INGRESS_DISABLE;
+    attr.value.booldata = !enableCollection;
+
+    status = sai_lag_api->set_lag_member_attribute(lagMember.m_lag_member_id, &attr);
+    if (status != SAI_STATUS_SUCCESS)
+    {
+        SWSS_LOG_ERROR("Failed to %s collection on LAG member %s",
+            enableCollection ? "enable" : "disable",
+            lagMember.m_alias.c_str());
+        return false;
+    }
+
+    return true;
+}
+
+bool PortsOrch::setDistributionOnLagMember(Port &lagMember, bool enableDistribution)
+{
+    /* Port must be LAG member */
+    assert(port.m_lag_member_id);
+
+    sai_status_t status = SAI_STATUS_FAILURE;
+    sai_attribute_t attr {};
+
+    attr.id = SAI_LAG_MEMBER_ATTR_EGRESS_DISABLE;
+    attr.value.booldata = !enableDistribution;
+
+    status = sai_lag_api->set_lag_member_attribute(lagMember.m_lag_member_id, &attr);
+    if (status != SAI_STATUS_SUCCESS)
+    {
+        SWSS_LOG_ERROR("Failed to %s distribution on LAG member %s",
+            enableDistribution ? "enable" : "disable",
+            lagMember.m_alias.c_str());
+        return false;
+    }
+
+    return true;
+}
+
 void PortsOrch::generateQueueMap()
 {
     if (m_isQueueMapGenerated)

Index: usonic/sm/sonic-swss/orchagent/portsorch.h

--- usonic.orig/sm/sonic-swss/orchagent/portsorch.h
+++ usonic/sm/sonic-swss/orchagent/portsorch.h
@@ -172,6 +172,8 @@ class PortsOrch : public Orch, public Subject
     bool removeLag(Port lag);
     bool addLagMember(Port &lag, Port &port);
     bool removeLagMember(Port &lag, Port &port);
+    bool setCollectionOnLagMember(Port &lagMember, bool enableCollection);
+    bool setDistributionOnLagMember(Port &lagMember, bool enableDistribution);
     void getLagMember(Port &lag, vector<Port> &portv);

     bool addPort(const set<int> &lane_set, uint32_t speed, int an=0, string fec="");
